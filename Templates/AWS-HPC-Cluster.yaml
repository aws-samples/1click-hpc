AWSTemplateFormatVersion: '2010-09-09'
Description: 1Click-HPC

Metadata: 
  AWS::CloudFormation::Interface:
    ParameterGroups: 
      - 
        Label: 
          default: ""
        Parameters: 
          - AdminPassword
          - VpcId
          - PublicSubnetId
          - PrivateSubnetAId
          - PrivateSubnetBId
          - FSx
          - AD
    ParameterLabels: 
      AdminPassword: 
        default: 'Password:'
      VpcId: 
        default: 'VPC:'
      PublicSubnetId: 
        default: 'Public Subnet:'      
      PrivateSubnetAId: 
        default: 'Private Subnet A:'
      PrivateSubnetBId: 
        default: 'Private Subnet B:'
      FSx: 
        default: 'FSx:'
      AD: 
        default: 'Active Directory:'
      S3Bucket: 
        default: 'S3 Bucket:'
        
Parameters:
    AdminPassword:
      Description: 'Please, enter the password for the user "ec2-user". Min 8 chars, three of: lowercase, uppercase, number and symbols'
      Type: String
      MinLength: '8'
      MaxLength: '255'
      AllowedPattern: (?=^.{8,255}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*
      NoEcho: 'true'

    VpcId:
      Description: 'Please, enter your VPC ID.'
      Type: String
      AllowedPattern: ^(vpc-[0-9a-z]+)$

    PublicSubnetId:
      Description: 'Please, enter the ID of the a Public subnet (can also be Private) with allowed internet accesss'
      Type: String
      AllowedPattern: ^(subnet-[0-9a-z]+)$
    
    PrivateSubnetAId:
      Description: 'Please, enter the ID of the first Private Subnet you wish to use (with no internet accesss).'
      Type: String
      AllowedPattern: ^(subnet-[0-9a-z]+)$

    PrivateSubnetBId:
      Description: 'Please, enter the ID of the second Private Subnet you wish to use (with no internet accesss).'
      Type: String
      AllowedPattern: ^(subnet-[0-9a-z]+)$

    FSx: 
      Description: 'Please, enter your FSx ID, or just leave "AUTO" if you want to re-use an existing one.'
      Type: String
      AllowedPattern: ^(AUTO|fs-[0-9a-z]+)$
      Default : AUTO

    AD:
      Description: 'Please, enter your Active Directory ID, or just leave "AUTO" if you want to create a new one.'
      Type: String
      AllowedPattern: ^(AUTO|d-[0-9a-z]+)$
      Default : AUTO
      
    S3Bucket:
      Description: 'Please, enter the S3 bucketname you with to use.'
      Type: String
      AllowedPattern: ^([a-z\\-]+)$

Mappings: 
  RegionMap: 
    us-east-1:
      ZoneId1: use1-az6
      ZoneId2: use1-az4
      DbInstanceType: db.t4g.micro
    us-east-2:
      ZoneId1: use2-az2
      ZoneId2: use2-az3
      DbInstanceType: db.t4g.micro
    us-west-1:
      ZoneId1: usw1-az1
      ZoneId2: usw1-az3
      DbInstanceType: db.t4g.micro
    us-west-2:
      ZoneId1: usw2-az1
      ZoneId2: usw2-az2
      DbInstanceType: db.t4g.micro
    eu-central-1:
      ZoneId1: euc1-az3
      ZoneId2: euc1-az2
      DbInstanceType: db.t4g.micro
    eu-west-1:
      ZoneId1: euw1-az1
      ZoneId2: euw1-az2
      DbInstanceType: db.t4g.micro
    eu-north-1:
      ZoneId1: eun1-az2
      ZoneId2: eun1-az1
      DbInstanceType: db.t4g.micro
    ca-central-1:
      ZoneId1: cac1-az2
      ZoneId2: cac1-az1
      DbInstanceType: db.t4g.micro
    eu-south-1:
      ZoneId1: eus1-az2
      ZoneId2: eus1-az1
      DbInstanceType: db.t3.micro
    ap-east-1:
      ZoneId1: ape1-az3
      ZoneId2: ape1-az2
      DbInstanceType: db.t4g.micro
    ap-northeast-1:
      ZoneId1: apne1-az4
      ZoneId2: apne1-az1
      DbInstanceType: db.t4g.micro
    ap-northeast-2:
      ZoneId1: apne2-az1
      ZoneId2: apne2-az3
      DbInstanceType: db.t4g.micro
    ap-south-1:
      ZoneId1: aps1-az2
      ZoneId2: aps1-az3
      DbInstanceType: db.t4g.micro

Conditions:
  CreateAD: !Equals [!Ref AD, AUTO]

Resources:

  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
            - ssm.amazonaws.com
            - s3.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AdministratorAccess
      - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Path: "/"

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
      - Ref: EC2Role

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName:
          Fn::Join:
          - ''
          - - LambdaExecutionRole-
            - Ref: AWS::Region
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: arn:aws:logs:*:*:*
          - Effect: Allow
            Action:
            - cloudformation:DescribeStacks
            - cloudformation:DescribeStackEvents
            - cloudformation:DescribeStackResource
            - cloudformation:DescribeStackResources
            - ec2:DescribeInstances
            - ec2:AssociateIamInstanceProfile
            - ec2:ModifyInstanceAttribute
            - ec2:ReplaceIamInstanceProfileAssociation
            - iam:ListInstanceProfiles
            - iam:PassRole
            Resource: "*"

  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Allow https and http'
      VpcId: !Ref VpcId
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 443
        ToPort: 443
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0

  PCAdditionalSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Allow 8443 and 80 from the ALB'
      VpcId: !Ref VpcId
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 8443
        ToPort: 8443
        SourceSecurityGroupId: !Ref ALBSecurityGroup
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        SourceSecurityGroupId: !Ref ALBSecurityGroup
      - IpProtocol: tcp
        FromPort: 389
        ToPort: 389
        SourceSecurityGroupId: !Ref ALBSecurityGroup
      - IpProtocol: udp
        FromPort: 389
        ToPort: 389
        SourceSecurityGroupId: !Ref ALBSecurityGroup

  DatabaseParameterGroup:
    Type: 'AWS::RDS::DBClusterParameterGroup'
    Properties:
      Description: Cluster parameter group for aurora-mysql5.7
      Family: aurora-mysql5.7
      Parameters:
        require_secure_transport: 'ON'
        innodb_lock_wait_timeout: '900'
      Tags:
        - Key: 'parallel-cluster:accounting'
          Value: rds-parameter-group
        - Key: 'parallel-cluster:accounting:scheduler'
          Value: slurm
        - Key: 'parallel-cluster:accounting:version'
          Value: '1.0'

  SlurmDBSubnetGroup: 
    Type: 'AWS::RDS::DBSubnetGroup'
    Properties:
      DBSubnetGroupDescription: SubnetGroup
        SubnetIds: 
          - !Ref PrivateSubnetAId
          - !Ref PrivateSubnetBId
  SlurmDBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Database SG'
      VpcId: !If [CreateVpc, !Ref VPC, !Ref VpcId]
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic by default
          IpProtocol: '-1'

  DatabaseSecurityGroupInboundRule:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      IpProtocol: tcp
      Description: Allow incoming connections from client security group
      FromPort: !GetAtt
        - SlurmDB
        - Endpoint.Port
      GroupId: !GetAtt
        - SlurmDBSecurityGroup
        - GroupId
      SourceSecurityGroupId: !GetAtt
        - DatabaseClientSecurityGroup
        - GroupId
      ToPort: !GetAtt
        - SlurmDB
        - Endpoint.Port
  SlurmDB:
    Type: 'AWS::RDS::DBInstance'
    Properties:
      DBInstanceIdentifier: !Sub '${AWS::StackName}-SlurmDB'
      DBInstanceClass: !FindInMap [RegionMap, !Ref "AWS::Region", DbInstanceType]
      MultiAZ: false
      AllocatedStorage: '20'
      StorageType: gp3
      MaxAllocatedStorage: 2000
      Engine: MySQL
      EngineVersion: 8.0.28
      MasterUsername: 'admin'
      MasterUserPassword: !Sub '{{resolve:secretsmanager:${Password}:SecretString:::}}'
      DBSubnetGroupName: !Ref SlurmDBSubnetGroup
      VPCSecurityGroups: 
        - !Ref 'SlurmDBSecurityGroup'

  DatabaseClientSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Security Group to allow connection to DB
      Tags:
        - Key: 'parallel-cluster:accounting'
          Value: client-security-group
        - Key: 'parallel-cluster:accounting:scheduler'
          Value: slurm
        - Key: 'parallel-cluster:accounting:version'
          Value: '1.0'
      VpcId: !If [CreateVpc, !Ref VPC, !Ref VpcId]
  DatabaseClientSecurityGroupOutboundRule:
    Type: 'AWS::EC2::SecurityGroupEgress'
    Properties:
      GroupId: !GetAtt
        - DatabaseClientSecurityGroup
        - GroupId
      IpProtocol: tcp
      Description: Allow incoming connections from PCluster
      DestinationSecurityGroupId: !GetAtt
        - SlurmDBSecurityGroup
        - GroupId
      FromPort: !GetAtt
        - SlurmDB
        - Endpoint.Port
      ToPort: !GetAtt
        - SlurmDB
        - Endpoint.Port

  EC2KeyPair:
    Type: 'AWS::EC2::KeyPair'
    Properties:
      KeyName: HPCKeyPair

  EC2Instance: 
    Type: AWS::EC2::Instance
    DependsOn: 
      - SlurmDB
    Properties: 
      ImageId: "ami-0ee415e1b8b71305f"
      KeyName: !Ref EC2KeyPair
      InstanceType: t2.micro
      UserData:
        Fn::Base64: 
          !Sub 
          - |
            #!/bin/bash
            if [[ -f /home/ec2-user/user-data.log ]]; then exit 1; fi
            set -x
            exec >/home/ec2-user/user-data.log; exec 2>&1 
            echo LANG=en_US.utf-8 >> /etc/environment
            echo LC_ALL=en_US.UTF-8 >> /etc/environment
            cd /home/ec2-user
            echo "export AWS_DEFAULT_REGION=${AWS::Region}" >> cluster_env
            echo "export AWS_REGION_NAME=${AWS::Region}" >> cluster_env
            echo "export S3_BUCKET=${S3Bucket}" >> cluster_env
            echo "export FSX_ID=${FSx}" >> cluster_env
            echo "export PRIVATE_SUBNET_A_ID=${PrivateSubnetAId}" >> cluster_env
            echo "export PRIVATE_SUBNET_B_ID=${PrivateSubnetBId}" >> cluster_env
            echo "export CLUSTER_NAME=${AWS::StackName}" >> cluster_env
            echo "export ADDITIONAL_SG=${PCAdditionalSecurityGroup}" >> cluster_env
            echo "export DB_SG=${DatabaseClientSecurityGroup}" >> cluster_env
            echo "export WAIT_HANDLE='${WaitHandle}'" >> cluster_env
            echo "export NLB_PUBLIC_DNS_NAME='${NetworkLoadBalancer.DNSName}'" >> cluster_env
            echo "export AD_ID=${ActiveDirectory}" >> cluster_env
            echo "export SLURM_DB_ENDPOINT='${SlurmDB.Endpoint.Address}'" >> cluster_env
            echo "export ALB_PUBLIC_DNS_NAME='${ApplicationLoadBalancer.DNSName}'" >> cluster_env
            echo "export KEY_PAIR=\"${AWS::StackName}-${RANDOM}\"" >> cluster_env
            aws s3 cp --quiet --recursive  "s3://${S3Bucket}/1click-hpc" /home/ec2-user/1click-hpc --region "${AWS::Region}"
            chmod +x /home/ec2-user/1click-hpc/scripts/EC2-Bootstrap.sh
            chown ec2-user:ec2-user /home/ec2-user/1click-hpc/scripts/EC2-Bootstrap.sh
            sudo -H -u ec2-user bash -c "bash /home/ec2-user/1click-hpc/scripts/EC2-Bootstrap.sh"
          - RANDOM: !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref 'AWS::StackId' ]]]]
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeType: "gp2"
            DeleteOnTermination: "true"
            VolumeSize: "30"
      NetworkInterfaces:
        - AssociatePublicIpAddress: "true"
          DeviceIndex: "0"
          SubnetId: !Ref PublicSubnetId
          GroupSet: 
            - !Ref EC2SecurityGroup
      IamInstanceProfile: !Ref EC2InstanceProfile
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-1Click"

  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Allow ssh from anywhere'
      VpcId: !Ref VpcId
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 0.0.0.0/0

  Password:
    Type: 'AWS::SecretsManager::Secret'
    Properties:
      Name: !Sub 'hpc-1click-${AWS::StackName}'
      Description: This the password used for RDS and ec2-user
      SecretString: !Ref AdminPassword

  WaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle

  WaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn:
    - EC2Instance
    Properties:
      Handle: !Ref WaitHandle
      Timeout: '3600'

  LambdaGetHeadNodeIP:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import logging
          import boto3
          import cfnresponse
          
          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)
          
          CFN = boto3.resource('cloudformation')
          
          
          def lambda_handler(event, context):
              if event['RequestType'] in ('Create', 'Update'):
                  try:
                      stack = CFN.Stack(event['ResourceProperties']['StackName'])
                      outputs = {
                          output['OutputKey']: output['OutputValue']
                          for output in stack.outputs
                      }
                  except Exception as error:
                      LOGGER.exception(error)
                      cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason=str(error))
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, outputs)
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 10
      MemorySize: 128

  LogGroupLambdaGetHeadNodeIP:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${LambdaGetHeadNodeIP}
      RetentionInDays: 7

  HeadNodeIP:
    Type: Custom::HeadNodeIP
    DependsOn: 
    - WaitCondition
    - LogGroupLambdaGetHeadNodeIP
    Properties:
      ServiceToken: !GetAtt LambdaGetHeadNodeIP.Arn
      StackName: !Sub 'hpc-1click-${AWS::StackName}'

  LBInit:
    Type: Custom::LBInit
    DependsOn: 
      - LogGroupLBInitLambda
    Properties:
      ServiceToken: !GetAtt LBInitLambda.Arn
      DNSName: !GetAtt ApplicationLoadBalancer.DNSName

  LogGroupLBInitLambda:
    Type: AWS::Logs::LogGroup
    DependsOn: LBInitLambda
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${LBInitLambda}
      RetentionInDays: 7

  LBInitLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Create ALB Certificate
      Timeout: 300
      Runtime: python3.7
      Handler: index.handler
      Role: !GetAtt 'LBInitRole.Arn'
      Code:
        ZipFile: |
          import boto3
          import os
          import subprocess
          import time
          import cfnresponse
          from botocore.exceptions import ClientError
          def handler(event, context):
              print(event)
              data = {}
              try:
                  if event['RequestType'] == 'Create':
                      IamCertificateArn = create_certificate(event)
                      data['IamCertificateArn'] = IamCertificateArn
                  elif event['RequestType'] == 'Delete':
                      delete_certificate(event)
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, data)
              except ClientError as e:
                  data['ClientErrorCode'] = e.response['Error']['Code']
                  data['ClientErrorMessage'] = e.response['Error']['Message']
                  cfnresponse.send(event, context, cfnresponse.FAILED, data)
              except Exception as e:
                  data['Exception'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, data)
          def create_certificate(event):
              DNSName = event['ResourceProperties']['DNSName']
              os.chdir('/tmp')
              config = open('/tmp/openssl.cnf', 'w+')
              config.write('[req]\nprompt=no\ndistinguished_name=enginframe\nx509_extensions=v3_req\n')
              config.write('[enginframe]\nC=US\nST=WA\nL=Seattle\nO=AWS WWSO\nOU=HPC\nCN=EnginFrame\n')
              config.write('[v3_req]\nkeyUsage=keyEncipherment,dataEncipherment,digitalSignature\nextendedKeyUsage=serverAuth\nsubjectAltName=@alt_names\n')
              config.write('[alt_names]\nDNS.1={}\n'.format(DNSName))
              config.close()
              os.environ['RANDFILE']='/tmp/.rnd'
              subprocess.run([
                  'openssl', 'req', '-new', '-x509', '-nodes',
                  '-newkey', 'rsa:2048', '-days', '3650',
                  '-keyout', '/tmp/key.pem', '-out', '/tmp/crt.pem',
                  '-config', '/tmp/openssl.cnf'
              ])
              os.remove('/tmp/openssl.cnf')
              keyfile = open('/tmp/key.pem', 'r')
              key = keyfile.read()
              keyfile.close()
              os.remove('/tmp/key.pem')
              crtfile = open('/tmp/crt.pem', 'r')
              crt = crtfile.read()
              crtfile.close()
              os.remove('/tmp/crt.pem')
              iam = boto3.client('iam')
              response = iam.upload_server_certificate(
                  ServerCertificateName=DNSName,
                  CertificateBody=crt,
                  PrivateKey=key
              )
              time.sleep(10)
              return response['ServerCertificateMetadata']['Arn']
          def delete_certificate(event):
              time.sleep(60)
              DNSName = event['ResourceProperties']['DNSName']
              iam = boto3.client('iam')
              response = iam.delete_server_certificate(ServerCertificateName=DNSName)

  LBInitRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - !Sub 'lambda.${AWS::URLSuffix}'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: EFLoadBalancer
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: iam
                Effect: Allow
                Action:
                  - iam:UploadServerCertificate
                  - iam:DeleteServerCertificate
                Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:server-certificate/${ApplicationLoadBalancer.DNSName}'

  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}'
      Subnets: 
        - !Ref PrivateSubnetAId
        - !Ref PrivateSubnetBId
      SecurityGroups:
        - !Ref ALBSecurityGroup
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: 180

#  NetworkLoadBalancer:
#    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
#    Properties:
#      Scheme: internal
#      Subnets: 
#        - !Ref PrivateSubnetAId
#        - !Ref PrivateSubnetBId
#      Type: network

#  LdapTargetGroup:
#    Type: AWS::ElasticLoadBalancingV2::TargetGroup
#    Properties:
#      Name: !Sub '${AWS::StackName}-Ldap'
#      Port: 389
#      Protocol: TCP
#      VpcId: !Ref VpcId
#      HealthCheckEnabled: True
#      HealthCheckIntervalSeconds: 10
#      HealthCheckPort: 389
#      HealthCheckProtocol: TCP
#      HealthCheckTimeoutSeconds: 10
#      HealthyThresholdCount: 3
#      TargetGroupAttributes:
#        - Key: deregistration_delay.timeout_seconds
#          Value: 60
#      Targets:
#        - Id: !Select [0, !GetAtt ActiveDirectory.DnsIpAddresses]
#          Port: 389
#        - Id: !Select [1, !GetAtt ActiveDirectory.DnsIpAddresses]
#          Port: 389
#      TargetType: ip

#  LdapListener:
#    Type: AWS::ElasticLoadBalancingV2::Listener
#    Properties:
#      DefaultActions:
#        - Type: forward
#          TargetGroupArn: !Ref LdapTargetGroup
#      LoadBalancerArn: !Ref NetworkLoadBalancer
#      Port: 636
#      Protocol: TLS
#      SslPolicy: ELBSecurityPolicy-TLS13-1-2-2021-06
#      Certificates:
#        - CertificateArn: !GetAtt LBInit.IamCertificateArn

  HTTPSListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: "HTTPS"
      SslPolicy: "ELBSecurityPolicy-2016-08"
      Certificates:
        - CertificateArn: !GetAtt LBInit.IamCertificateArn
      DefaultActions: 
        - 
          Order: 1
          TargetGroupArn: !Ref TargetGroupEF
          Type: "forward"

  GrafanaListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
      - Type: forward
        TargetGroupArn: !Ref TargetGroupMonitoring
      Conditions:
      - Field: path-pattern
        Values:
        - "/grafana*"
      ListenerArn: !Ref HTTPSListener
      Priority: 1
      
  PrometheusListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
      - Type: forward
        TargetGroupArn: !Ref TargetGroupMonitoring
      Conditions:
      - Field: path-pattern
        Values:
        - "/prometheus*"
      ListenerArn: !Ref HTTPSListener
      Priority: 2

  HTTPListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: "HTTP"
      DefaultActions: 
        - 
          Order: 1
          RedirectConfig: 
            Protocol: "HTTPS"
            Port: "443"
            Host: "#{host}"
            Path: "/#{path}"
            Query: "#{query}"
            StatusCode: "HTTP_301"
          Type: "redirect"

  TargetGroupEF:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: 
      - HeadNodeIP
    Properties:
      Name: !Sub '${AWS::StackName}-EF'
      VpcId: !Ref VpcId
      Port: 8443
      Protocol: HTTPS
      Targets:
        - Id: !Sub '${HeadNodeIP.HeadNodePrivateIP}'
      TargetType: ip
  
  TargetGroupMonitoring:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: 
      - HeadNodeIP
    Properties:
      Name: !Sub '${AWS::StackName}-Monitoring'
      VpcId: !Ref VpcId
      Port: 80
      Protocol: HTTP
      Targets:
        - Id: !Sub '${HeadNodeIP.HeadNodePrivateIP}'
      TargetType: ip
      HealthCheckPath: '/grafana'
      Matcher: 
        HttpCode: '200,301,302'

  AvailabiltyZone1:
    Type: Custom::AvailabiltyZone
    DependsOn: LogGroupGetAZLambdaFunction
    Properties:
      ServiceToken: !GetAtt GetAZLambdaFunction.Arn
      ZoneId: !FindInMap [RegionMap, !Ref "AWS::Region", ZoneId1]

  AvailabiltyZone2:
    Type: Custom::AvailabiltyZone
    DependsOn: LogGroupGetAZLambdaFunction
    Properties:
      ServiceToken: !GetAtt GetAZLambdaFunction.Arn
      ZoneId: !FindInMap [RegionMap, !Ref "AWS::Region", ZoneId2]

  LogGroupGetAZLambdaFunction:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${GetAZLambdaFunction}
      RetentionInDays: 7

  GetAZLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: GetAZLambdaFunction
      Timeout: 60
      Runtime: python3.7
      Handler: index.handler
      Role: !GetAtt GetAZLambdaRole.Arn
      Code:
        ZipFile: |
          import cfnresponse
          from json import dumps
          from boto3 import client
          EC2 = client('ec2')
          def handler(event, context):
              if event['RequestType'] in ('Create', 'Update'):
                  print(dumps(event, default=str))
                  data = {}
                  try:
                      response = EC2.describe_availability_zones(
                          Filters=[{'Name': 'zone-id', 'Values': [event['ResourceProperties']['ZoneId']]}]
                      )
                      print(dumps(response, default=str))
                      data['ZoneName'] = response['AvailabilityZones'][0]['ZoneName']
                  except Exception as error:
                      cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason=error)
                  finally:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, data)
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-GetAZLambdaFunction

  GetAZLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      Description: GetAZLambdaFunction
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - !Sub 'lambda.${AWS::URLSuffix}'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: GetAZLambdaFunction
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ec2
                Effect: Allow
                Action:
                  - ec2:DescribeAvailabilityZones
                Resource:
                  - '*'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-GetAZLambdaFunction

#  ActiveDirectory:
#    Type: AWS::DirectoryService::MicrosoftAD
#    Condition: CreateAD
#    Properties: 
#      Edition: Standard
#      Name: corp.pcluster.com
#      Password: !Ref AdminPassword
#      ShortName: corp
#      VpcSettings: 
#        SubnetIds: 
#          - !Ref PrivateSubnetAId
#          - !Ref PrivateSubnetBId
#        VpcId: !Ref VpcId

Outputs:

  WebURL:
    Description: "EnginFrame HPC Portal and Grafana Monitoring Dashboard."
    Value: !Sub 
      - 'https://${ALB}/'
      - ALB: !GetAtt ApplicationLoadBalancer.DNSName
